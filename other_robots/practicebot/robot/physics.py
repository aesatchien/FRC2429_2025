import math
from rev import SparkMaxSim, SparkSim
from wpimath.kinematics._kinematics import SwerveDrive4Kinematics

from subsystems.lower_crank import LowerCrank
import wpilib
import wpilib.simulation as simlib  # 2021 name for the simulation library
import wpimath.geometry as geo
from pyfrc.physics.core import PhysicsInterface
import wpilib.simulation
from wpimath.system.plant import DCMotor
from robot import MyRobot
import constants

class PhysicsEngine:

    def __init__(self, physics_controller: PhysicsInterface, robot: MyRobot):
        # Copied from 2024 code
        self.physics_controller = physics_controller  # must have for simulation
        self.robot = robot

        self.kinematics: SwerveDrive4Kinematics = dc.kDriveKinematics  # our swerve drive kinematics

        # set up LEDs - apparently not necessary - glass gui grabs the default one and you can show it
        # self.ledsim = simlib.AddressableLEDSim()

        # NavX (SPI interface) - no idea why the "4" is there, seems to be the default name generated by the navx code
        self.navx = simlib.SimDeviceSim("navX-Sensor[4]")
        self.navx_yaw = self.navx.getDouble("Yaw")  # for some reason it seems we have to set Yaw and not Angle
        self.navx_angle = self.navx.getDouble("Angle")

        self.analogs = [simlib.AnalogInputSim(i) for i in range(4)]
        self.analog_offsets = []

        # create a dictionary so we can refer to the sparks by name and get their relevant parameters
        self.spark_dict = {}
        # kinematics chassis speeds wants them in same order as in original definition - unfortunate ordering
        self.spark_drives = ['lf_drive', 'rf_drive', 'lb_drive', 'rb_drive']
        self.spark_drive_ids = [21, 25, 23, 27]  # keep in this order - based on our kinematics definition
        self.spark_turns = ['lf_turn', 'rf_turn', 'lb_turn', 'rb_turn']
        self.spark_turn_ids = [20, 24, 22, 26]  # keep in this order

        # Got rid of last year's elements: 'br_crank', 'bl_crank', 'tr_crank', 'tl_crank', 't_shooter', 'b_shooter'
        self.spark_peripherals = ['intake', 'indexer']
        self.spark_peripheral_ids = [5, 12] # Kept  'indexer' id as 12 because it came last before removing the elements

        # allow ourselves to access the simdevice's Position, Velocity, Applied Output, etc
        self.spark_names = self.spark_drives + self.spark_turns + self.spark_peripherals
        self.spark_ids = self.spark_drive_ids + self.spark_turn_ids + self.spark_peripheral_ids
        for idx, (spark_name, can_id) in enumerate(zip(self.spark_names, self.spark_ids)):
            spark = simlib.SimDeviceSim(f'SPARK MAX [{can_id}]')
            position = spark.getDouble('Position')
            velocity = spark.getDouble('Velocity')
            output = spark.getDouble('Applied Output')
            self.spark_dict.update({spark_name: {'controller': spark, 'position': position,
                                                 'velocity': velocity, 'output': output}})
        for key, value in self.spark_dict.items():  # see if these make sense
            print(f'{key}: {value}')

        self.distances = [0, 0, 0, 0]

        # set up the initial location of the robot on the field
        self.x, self.y = constants.k_start_x, constants.k_start_y
        self.theta = 0
        initial_pose = geo.Pose2d(0, 0, geo.Rotation2d())
        self.physics_controller.move_robot(geo.Transform2d(self.x, self.y, 0))

        """
        self.physics_controller = physics_controller
        self.robot = robot
        
        self.crank_arm_plant = DCMotor.NEO(1)

        self.arm_sim = wpilib.simulation.SingleJointedArmSim(
                self.crank_arm_plant,
                constants.LowerCrankConstants.k_gear_ratio,
                wpilib.simulation.SingleJointedArmSim.estimateMOI(length=constants.LowerCrankConstants.k_length_meters,
                                                                  mass=constants.LowerCrankConstants.k_mass_kg),
                armLength=constants.LowerCrankConstants.k_length_meters,
                minAngle=math.radians(40),
                maxAngle=math.radians(116),
                simulateGravity=True,
                startingAngle=constants.LowerCrankConstants.k_lower_crank_sim_starting_angle
        )

        self.arm_spark_sim = SparkMaxSim(self.robot.container.lower_crank.sparkmax, self.crank_arm_plant)
        self.arm_spark_sim.setPosition(constants.LowerCrankConstants.k_lower_crank_sim_starting_angle)
        self.arm_spark_sim.enable()
        # self.arm_encoder_sim = self.arm_spark_sim.getRelativeEncoderSim()

        self.arm_mech2d = wpilib.Mechanism2d(60, 60)
        self.mech2d_root = self.arm_mech2d.getRoot(name="root", x=40, y=10)
        self.base_mech2d = self.mech2d_root.appendLigament("frame", length=-20, angle=0)
        self.crank_mech2d = self.base_mech2d.appendLigament(name="crank", length=20, angle=self.arm_sim.getAngle())

        self.base_mech2d.setColor(wpilib.Color8Bit(200, 200, 200))

        wpilib.SmartDashboard.putData("arm mech 2d", self.arm_mech2d)

        # self.arm_motor: SimCANSparkMax = self.robot.container.lower_crank.sparkmax
        # self.arm_motor_sim = wpilib.simulation.PWMSim(self.arm_motor)
        """


    def update_sim(self, now, tm_diff):
        pass
        """
        # print(f"voltage: {wpilib.RobotController.getInputVoltage()}")
        # print(f"now: {now}")
        if now > 10:
            self.arm_sim.setInput(0, self.arm_spark_sim.getAppliedOutput() * wpilib.RobotController.getInputVoltage())
        else:
            self.arm_sim.setInput(0, 0.5)

        self.arm_sim.update(tm_diff)

        wpilib.simulation.RoboRioSim.setVInVoltage(
                wpilib.simulation.BatterySim.calculate([self.arm_sim.getCurrentDraw()])
        )

        voltage = wpilib.simulation.RoboRioSim.getVInVoltage()
        # print(f"rio sim voltage: {wpilib.simulation.RoboRioSim.getVInVoltage()}")
        
        # self.arm_encoder_sim.setPosition(self.arm_sim.getAngle())
        # self.arm_spark_sim.setPosition(self.arm_sim.getAngle())
        self.arm_spark_sim.iterate(math.radians(self.arm_sim.getVelocityDps()), voltage, tm_diff)
        # self.robot.container.lower_crank.set_encoder_position(self.arm_sim.getAngle())

        self.crank_mech2d.setAngle(math.degrees(self.arm_sim.getAngle()))

        # l_encoder = self.drivetrain.wheelSpeeds.left * tm_diff
        """